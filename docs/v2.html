<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eternal Struggle - Updated Layout</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1c1c4f;
            color: antiquewhite;
            padding: 20px;
            transition: background 0.5s ease;
        }

        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 900px;
            width: 100%;
            background: rgba(28, 28, 79, 0.8);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            color: antiquewhite;
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 25px;
            text-align: center;
            max-width: 600px;
            color: #d0c6b3;
        }

        .canvas-container {
            position: relative;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        canvas {
            display: block;
            background-color: antiquewhite;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            background: rgba(39, 39, 109, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        .control-title {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: antiquewhite;
        }

        button {
            padding: 12px 20px;
            background: #4c4c9f;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 5px 0;
            transition: all 0.3s;
        }

        button:hover {
            background: #5c5cbf;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            margin: 10px 0;
        }

        .slider-container label {
            margin-bottom: 8px;
            font-weight: 500;
        }

        .value-display-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .speed-input {
            width: 70px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid antiquewhite;
            background-color: rgba(39, 39, 109, 0.7);
            color: antiquewhite;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            -moz-appearance: textfield; /* For Firefox */
        }

        .speed-input::-webkit-outer-spin-button,
        .speed-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            background: rgba(250, 235, 215, 0.3);
            border-radius: 4px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: antiquewhite;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        .value-display {
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
            color: antiquewhite;
        }

        .instructions {
            margin-top: 25px;
            padding: 15px;
            background: rgba(39, 39, 109, 0.7);
            border-radius: 10px;
            width: 100%;
        }

        .instructions h3 {
            margin-bottom: 10px;
            text-align: center;
            color: antiquewhite;
        }

        .instructions ul {
            list-style-type: none;
            padding: 0 15px;
        }

        .instructions li {
            margin: 8px 0;
            display: flex;
            align-items: flex-start;
        }

        .instructions li::before {
            content: "â€¢";
            color: antiquewhite;
            font-weight: bold;
            display: inline-block;
            width: 20px;
        }

        @media (max-width: 600px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }

            .control-group {
                width: 100%;
            }

            h1 {
                font-size: 2.2rem;
            }

            .subtitle {
                font-size: 1rem;
            }
        }
    </style>
</head>
<body>
<div class="container">
    <h1>Eternal Struggle - Updated Layout</h1>
    <p class="subtitle">Two opposing forces in perpetual motion within a confined space</p>

    <div class="canvas-container">
        <canvas id="simulationCanvas" width="400" height="400"></canvas>
    </div>

    <div class="controls">
        <div class="control-group">
            <div class="control-title">Simulation Controls</div>
            <div class="slider-container">
                <label for="speedSlider">Simulation Speed:</label>
                <input type="range" id="speedSlider" min="0.1" max="100" step="0.1" value="1.0">
                <div class="value-display-container">
                    <span class="value-display" id="speedValue">1.0x</span>
                    <input type="number" id="speedInput" class="speed-input" min="0.1" step="0.1" value="1.0">
                </div>
            </div>
            <button id="pauseButton">Pause</button>
            <button id="resetButton">Reset</button>
        </div>

        <div class="control-group">
            <div class="control-title">Appearance</div>
            <button id="togglePoints">Toggle Points</button>
            <button id="themeButton">Change Theme</button>
            <button id="resetThemeButton">Reset Theme</button>
        </div>

        <div class="control-group">
            <div class="control-title">Ball Properties</div>
            <div class="slider-container">
                <label for="sizeSlider">Ball Size:</label>
                <input type="range" id="sizeSlider" min="15" max="35" step="1" value="25">
                <div class="value-display" id="sizeValue">25px</div>
            </div>
            <div class="slider-container">
                <label for="velocitySlider">Initial Velocity:</label>
                <input type="range" id="velocitySlider" min="1" max="8" step="0.5" value="4">
                <div class="value-display" id="velocityValue">4.0</div>
            </div>
        </div>
    </div>
</div>

<script>
    // Constants and configuration
    const CENTER = { x: 200, y: 200 };
    const MAIN_RADIUS = 180;
    const MED_RADIUS = 90;
    let SMALL_RADIUS = 25;
    let SHOW_POINTS = false;
    let PAUSED = true;
    let BACKGROUND_COLOR = "antiquewhite";
    let SIMULATION_SPEED = 1.0;
    let INITIAL_VELOCITY = 4.0;

    // Canvas setup
    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');

    // Data structure for the simulation
    const data = {
        border: [],
        whiteOuter: [],
        whiteBall: { x: 0, y: 0, r: SMALL_RADIUS, v: { x: 0, y: 0 } },
        blackBall: { x: 0, y: 0, r: SMALL_RADIUS, v: { x: 0, y: 0 } }
    };

    // Utility functions
    function degreesToRadians(deg) {
        return deg * Math.PI / 180;
    }

    function normalize(p) {
        const len = Math.sqrt(p.x * p.x + p.y * p.y);
        if (len === 0) return { x: 0, y: 0 };
        return { x: p.x / len, y: p.y / len };
    }

    function dot(p1, p2) {
        return p1.x * p2.x + p1.y * p2.y;
    }

    function len(v) {
        return Math.sqrt(dot(v, v));
    }

    function sub(p1, p2) {
        return { x: p1.x - p2.x, y: p1.y - p2.y };
    }

    function mult(p, s) {
        return { x: p.x * s, y: p.y * s };
    }

    function dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function distToLineSegment(item, p1, p2) {
        const l2 = dist(p1, p2) ** 2;
        if (l2 === 0) return dist(item, p1);

        let t = ((item.x - p1.x) * (p2.x - p1.x) + (item.y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));

        return dist(item, {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
        });
    }

    // Generate points along an arc
    function arcOfPoints(cx, cy, r, fromDeg, toDeg, nPoints) {
        const points = [];
        const fromRad = degreesToRadians(fromDeg);
        const toRad = degreesToRadians(toDeg);
        const angleRange = toRad - fromRad;

        for (let i = 0; i < nPoints; i++) {
            const angle = fromRad + (angleRange * i / nPoints);
            points.push({
                x: cx + Math.cos(angle) * r,
                y: cy + Math.sin(angle) * r
            });
        }
        return points;
    }

    // Physics calculations
    function bounceFromCircle(c, item, itemV) {
        const directionOfHitPoint = normalize(sub(item, c));
        const normal = directionOfHitPoint;
        const v = normalize(itemV);
        const projectedVelocity = dot(normal, v);
        const newDir = sub(v, mult(normal, 2 * projectedVelocity));
        return mult(newDir, len(itemV));
    }

    // Initialize simulation
    function initSimulation() {
        const blackBorder = arcOfPoints(CENTER.x, CENTER.y + MED_RADIUS, MED_RADIUS, 90, 270, 60);
        const whiteBorder = arcOfPoints(CENTER.x, CENTER.y - MED_RADIUS, MED_RADIUS, 90, -90, 60);

        data.border = [...blackBorder, ...whiteBorder];
        data.whiteOuter = arcOfPoints(CENTER.x, CENTER.y, MAIN_RADIUS, 270, 450, 60);

        // --- MODIFIED ---
        // Generate random starting angles for the balls
        const whiteAngle = Math.random() * Math.PI * 2;
        const blackAngle = Math.random() * Math.PI * 2;

        data.whiteBall = {
            x: CENTER.x,
            y: CENTER.y - MED_RADIUS,
            r: SMALL_RADIUS,
            v: {
                x: Math.cos(whiteAngle) * INITIAL_VELOCITY,
                y: Math.sin(whiteAngle) * INITIAL_VELOCITY
            }
        };

        data.blackBall = {
            x: CENTER.x,
            y: CENTER.y + MED_RADIUS,
            r: SMALL_RADIUS,
            v: {
                x: Math.cos(blackAngle) * INITIAL_VELOCITY,
                y: Math.sin(blackAngle) * INITIAL_VELOCITY
            }
        };
    }

    // Refill border points to prevent tunneling
    function refillBorder(points) {
        const MIN_DISTANCE = 8; // Minimum distance between points
        const MAX_DISTANCE = 15; // Maximum distance between points

        let newPoints = [points[0]];

        // First pass: add points where gaps are too large
        for (let i = 1; i < points.length; i++) {
            const p1 = points[i-1];
            const p2 = points[i];
            const distance = dist(p1, p2);

            if (distance > MAX_DISTANCE) {
                // Add intermediate points
                const segments = Math.ceil(distance / MAX_DISTANCE);
                for (let j = 1; j < segments; j++) {
                    const ratio = j / segments;
                    newPoints.push({
                        x: p1.x + (p2.x - p1.x) * ratio,
                        y: p1.y + (p2.y - p1.y) * ratio
                    });
                }
            }

            newPoints.push(p2);
        }

        // Second pass: remove points that are too close together
        const filteredPoints = [newPoints[0]];
        for (let i = 1; i < newPoints.length; i++) {
            const lastPoint = filteredPoints[filteredPoints.length - 1];
            const currentPoint = newPoints[i];

            if (dist(lastPoint, currentPoint) >= MIN_DISTANCE) {
                filteredPoints.push(currentPoint);
            }
        }

        return filteredPoints;
    }

    // --- MODIFIED FUNCTION ---
    // Move an object based on its velocity.
    // The SIMULATION_SPEED multiplier has been removed. Speed is now controlled by the update frequency in the animate() loop.
    function move(item) {
        return {
            ...item,
            x: item.x + item.v.x,
            y: item.y + item.v.y
        };
    }

    // Handle collisions
    function handleCollisions() {
        for (const ball of [data.whiteBall, data.blackBall]) {
            let movedBall = move(ball);
            let newV = { ...ball.v };
            let hit = false;
            const hitPoints = [];

            const newBorder = [];
            for (const p of data.border) {
                if (dist(p, movedBall) < ball.r - 4) {
                    const movedPoint = {
                        x: p.x + (newV.x * 1.5),
                        y: p.y + (newV.y * 1.5)
                    };

                    if (dist(movedPoint, CENTER) >= MAIN_RADIUS) {
                        newBorder.push(p);
                    } else {
                        newBorder.push(movedPoint);
                    }

                    hitPoints.push(p);
                    hit = true;
                } else {
                    newBorder.push(p);
                }
            }

            if (dist(movedBall, CENTER) >= MAIN_RADIUS - ball.r) {
                newV = bounceFromCircle(CENTER, movedBall, newV);
            } else if (hit) {
                newV = bounceFromCircle(hitPoints[0], movedBall, newV);
            }

            // Refill border to prevent tunneling
            data.border = refillBorder(newBorder);

            if (ball === data.whiteBall) {
                data.whiteBall = { ...ball, v: newV };
            } else {
                data.blackBall = { ...ball, v: newV };
            }
        }
    }

    // Render the simulation
    function render() {
        // Clear canvas
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw main circle
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.arc(CENTER.x, CENTER.y, MAIN_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Draw white area
        ctx.fillStyle = "white";
        ctx.beginPath();

        // Add white outer points
        if (data.whiteOuter.length > 0) {
            ctx.moveTo(data.whiteOuter[0].x, data.whiteOuter[0].y);
            for (let i = 1; i < data.whiteOuter.length; i++) {
                ctx.lineTo(data.whiteOuter[i].x, data.whiteOuter[i].y);
            }
        }

        // Add border points
        if (data.border.length > 0) {
            ctx.lineTo(data.border[0].x, data.border[0].y);
            for (let i = 1; i < data.border.length; i++) {
                ctx.lineTo(data.border[i].x, data.border[i].y);
            }
        }

        ctx.closePath();
        ctx.fill();

        // Draw points if enabled
        if (SHOW_POINTS) {
            ctx.fillStyle = "red";
            for (const point of data.border) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            for (const point of data.whiteOuter) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw white ball
        ctx.fillStyle = data.whiteBallColor || "white";
        ctx.beginPath();
        ctx.arc(data.whiteBall.x, data.whiteBall.y, data.whiteBall.r, 0, Math.PI * 2);
        ctx.fill();

        // Draw black ball
        ctx.fillStyle = data.blackBallColor || "black";
        ctx.beginPath();
        ctx.arc(data.blackBall.x, data.blackBall.y, data.blackBall.r, 0, Math.PI * 2);
        ctx.fill();

        // Draw pause indicator if paused
        if (PAUSED) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "white";
            ctx.font = "bold 36px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
        }
    }

    // --- Game Loop with Fixed Timestep ---
    let lastTime = 0;
    let accumulator = 0;
    const dt = 1000 / 60; // Fixed timestep for physics updates (60 updates per second).

    function animate(currentTime = 0) {
        if (!lastTime) {
            lastTime = currentTime;
        }
        const frameTime = currentTime - lastTime;
        lastTime = currentTime;

        // Add frame time to accumulator, scaled by the simulation speed.
        // This allows the simulation to run faster or slower than real-time.
        accumulator += frameTime * SIMULATION_SPEED;

        // Process physics updates in fixed steps (dt) until the accumulator is caught up.
        while (accumulator >= dt) {
            if (!PAUSED) {
                handleCollisions();
                data.whiteBall = move(data.whiteBall);
                data.blackBall = move(data.blackBall);

                // Keep balls within bounds after moving
                if (dist(data.whiteBall, CENTER) > MAIN_RADIUS - data.whiteBall.r) {
                    const angle = Math.atan2(data.whiteBall.y - CENTER.y, data.whiteBall.x - CENTER.x);
                    data.whiteBall.x = CENTER.x + Math.cos(angle) * (MAIN_RADIUS - data.whiteBall.r - 1);
                    data.whiteBall.y = CENTER.y + Math.sin(angle) * (MAIN_RADIUS - data.whiteBall.r - 1);
                }

                if (dist(data.blackBall, CENTER) > MAIN_RADIUS - data.blackBall.r) {
                    const angle = Math.atan2(data.blackBall.y - CENTER.y, data.blackBall.x - CENTER.x);
                    data.blackBall.x = CENTER.x + Math.cos(angle) * (MAIN_RADIUS - data.blackBall.r - 1);
                    data.blackBall.y = CENTER.y + Math.sin(angle) * (MAIN_RADIUS - data.blackBall.r - 1);
                }
            }
            accumulator -= dt;
        }

        // Render the current state. This is done once per frame, regardless of physics updates.
        render();
        requestAnimationFrame(animate);
    }

    // Set up event listeners
    function setupEventListeners() {
        // Mouse movement to start simulation
        canvas.addEventListener('mousemove', () => {
            if (PAUSED) {
                PAUSED = false;
                document.getElementById('pauseButton').textContent = 'Pause';
            }
        });

        // Pause button
        document.getElementById('pauseButton').addEventListener('click', () => {
            PAUSED = !PAUSED;
            document.getElementById('pauseButton').textContent = PAUSED ? 'Resume' : 'Pause';
        });

        // Reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            initSimulation();
            PAUSED = false;
            document.getElementById('pauseButton').textContent = 'Pause';
        });

        // Toggle points button
        document.getElementById('togglePoints').addEventListener('click', () => {
            SHOW_POINTS = !SHOW_POINTS;
        });

        // Theme button
        document.getElementById('themeButton').addEventListener('click', () => {
            const colors = [
                '#1c1c4f', '#4f1c1c', '#1c4f1c', '#4f4f1c', '#1c4f4f',
                '#4f1c4f', '#3c1c6f', '#6f3c1c', '#1c6f3c', '#6f6f1c'
            ];

            // Generate random colors for elements
            const bgColor = colors[Math.floor(Math.random() * colors.length)];
            const uiColor = colors[Math.floor(Math.random() * colors.length)];

            // Update background
            document.body.style.background = bgColor;
            document.querySelector('.container').style.background = `rgba(${parseInt(bgColor.slice(1, 3), 16)}, ${parseInt(bgColor.slice(3, 5), 16)}, ${parseInt(bgColor.slice(5, 7), 16)}, 0.8)`;

            // Update UI colors
            document.querySelectorAll('.control-group').forEach(el => {
                el.style.background = `rgba(${parseInt(uiColor.slice(1, 3), 16)}, ${parseInt(uiColor.slice(3, 5), 16)}, ${parseInt(uiColor.slice(5, 7), 16)}, 0.7)`;
            });

            document.querySelectorAll('button').forEach(btn => {
                btn.style.background = uiColor;
            });
        });

        // Reset Theme button
        document.getElementById('resetThemeButton').addEventListener('click', () => {
            // Reset background colors
            document.body.style.background = '#1c1c4f';
            document.querySelector('.container').style.background = 'rgba(28, 28, 79, 0.8)';

            // Reset ball colors
            data.whiteBallColor = null;
            data.blackBallColor = null;

            // Reset UI colors
            document.querySelectorAll('.control-group').forEach(el => {
                el.style.background = 'rgba(39, 39, 109, 0.7)';
            });

            document.querySelectorAll('button').forEach(btn => {
                btn.style.background = '#4c4c9f';
            });
        });

        // Speed slider
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const newSpeed = parseFloat(e.target.value);
            SIMULATION_SPEED = newSpeed;
            document.getElementById('speedValue').textContent = `${newSpeed.toFixed(1)}x`;
            document.getElementById('speedInput').value = newSpeed.toFixed(1);
        });

        // Custom speed input
        document.getElementById('speedInput').addEventListener('change', (e) => {
            let newSpeed = parseFloat(e.target.value);

            // Validate the input
            if (isNaN(newSpeed) || newSpeed < 0.1) {
                newSpeed = 0.1;
            }

            SIMULATION_SPEED = newSpeed;

            // Update the slider's position, clamping it to its max value if the input is higher
            const speedSlider = document.getElementById('speedSlider');
            if (newSpeed > parseFloat(speedSlider.max)) {
                speedSlider.value = speedSlider.max;
            } else {
                speedSlider.value = newSpeed;
            }

            // Update the text displays
            document.getElementById('speedValue').textContent = `${newSpeed.toFixed(1)}x`;
            e.target.value = newSpeed.toFixed(1); // Format the input field's value
        });

        // Size slider
        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            SMALL_RADIUS = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = `${SMALL_RADIUS}px`;

            data.whiteBall.r = SMALL_RADIUS;
            data.blackBall.r = SMALL_RADIUS;
        });

        // Velocity slider
        document.getElementById('velocitySlider').addEventListener('input', (e) => {
            INITIAL_VELOCITY = parseFloat(e.target.value);
            document.getElementById('velocityValue').textContent = INITIAL_VELOCITY.toFixed(1);

            // Reinitialize to apply new velocity
            initSimulation();
        });
    }

    // Initialize and start the simulation
    function init() {
        initSimulation();
        setupEventListeners();
        // Start the animation loop
        requestAnimationFrame(animate);
    }

    // Start everything when the page loads
    window.addEventListener('load', init);
</script>
</body>
</html>

