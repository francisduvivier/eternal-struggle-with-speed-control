<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eternal Struggle - Cleaned UI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1c1c4f;
            color: antiquewhite;
            padding: 20px;
            transition: background 0.5s ease;
        }

        .container {
            position: relative; /* Added for positioning the GitHub link */
            display: flex;
            flex-direction: column;
            align-items: center;
            max-width: 900px;
            width: 100%;
            background: rgba(28, 28, 79, 0.8);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }

        .github-link {
            position: absolute;
            top: 25px;
            right: 25px;
            color: antiquewhite;
            width: 32px;
            height: 32px;
            transition: color 0.3s ease, transform 0.3s ease;
        }

        .github-link:hover {
            color: #fff;
            transform: scale(1.1);
        }

        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-align: center;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            color: antiquewhite;
        }

        .subtitle {
            font-size: 1.2rem;
            margin-bottom: 25px;
            text-align: center;
            max-width: 600px;
            color: #d0c6b3;
        }

        .canvas-container {
            position: relative;
            margin: 20px 0;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        canvas {
            display: block;
            background-color: antiquewhite;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
            width: 100%;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            background: rgba(39, 39, 109, 0.7);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
        }

        .control-title {
            font-weight: bold;
            margin-bottom: 10px;
            text-align: center;
            color: antiquewhite;
        }

        button {
            padding: 12px 20px;
            background: #4c4c9f;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 5px 0;
            transition: all 0.3s;
        }

        button:hover {
            background: #5c5cbf;
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            margin: 15px 0;
        }

        .slider-container label {
            margin-bottom: 8px;
            font-weight: 500;
        }

        .value-display-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-top: 5px;
        }

        .speed-input {
            width: 70px;
            padding: 5px;
            border-radius: 4px;
            border: 1px solid antiquewhite;
            background-color: rgba(39, 39, 109, 0.7);
            color: antiquewhite;
            text-align: center;
            font-weight: bold;
            font-size: 14px;
            -moz-appearance: textfield; /* For Firefox */
        }

        .speed-input::-webkit-outer-spin-button,
        .speed-input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input[type="range"] {
            width: 100%;
            height: 12px;
            -webkit-appearance: none;
            background: rgba(250, 235, 215, 0.3);
            border-radius: 6px;
            outline: none;
            margin: 5px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: antiquewhite;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            margin-top: -9px; /* Center thumb on the track */
            transition: transform 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: antiquewhite;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            border: none;
            transition: transform 0.2s ease;
        }

        input[type="range"]:active::-webkit-slider-thumb,
        input[type="range"]:active::-moz-range-thumb {
            transform: scale(1.2);
        }

        .value-display {
            font-weight: bold;
            text-align: center;
            margin-top: 5px;
            color: antiquewhite;
        }

        #fullscreenButton {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 10;
            padding: 8px 12px;
            font-size: 14px;
            margin: 0;
            opacity: 0.7;
        }

        #fullscreenButton:hover {
            opacity: 1;
        }

        .canvas-container.fullscreen-active {
            width: 100vw;
            height: 100vh;
            border-radius: 0;
            margin: 0;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #000;
        }

        .canvas-container.fullscreen-active canvas {
            width: 100vmin;
            height: 100vmin;
            border-radius: 0;
        }

        .container.fullscreen-mode {
            max-width: 100%;
            height: 100vh;
            width: 100vw;
            border-radius: 0;
            overflow-y: auto;
            padding: 2vw;
        }

        @media (max-width: 600px) {
            .controls {
                flex-direction: column;
                align-items: center;
            }

            .control-group {
                width: 100%;
            }

            h1 {
                font-size: 2.2rem;
            }

            .subtitle {
                font-size: 1rem;
            }
        }
        .color-picker-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .color-picker-container label {
            font-weight: 500;
            margin-right: 10px;
        }

        input[type="color"] {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 35px;
            height: 35px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background-color: transparent;
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
            border-radius: 8px;
        }

        input[type="color"]::-webkit-color-swatch {
            border: 2px solid antiquewhite;
            border-radius: 8px;
        }

        input[type="color"]::-moz-color-swatch {
            border: 2px solid antiquewhite;
            border-radius: 8px;
        }
    </style>
</head>
<body>
<div class="container">
    <a href="https://github.com/francisduvivier/eternal-struggle-with-speed-control/blob/main/docs/v2.html" target="_blank" rel="noopener noreferrer" class="github-link" aria-label="View source on GitHub">
        <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
            <path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/>
        </svg>
    </a>
    <h1>Eternal Struggle - Cleaned UI</h1>
    <p class="subtitle">Two opposing forces in perpetual motion within a confined space</p>

    <div class="canvas-container">
        <canvas id="simulationCanvas" width="400" height="400"></canvas>
        <button id="fullscreenButton">Fullscreen</button>
    </div>

    <div class="controls">
        <div class="control-group">
            <div class="control-title">Simulation Controls</div>
            <div class="slider-container">
                <label for="speedSlider">Simulation Speed:</label>
                <input type="range" id="speedSlider" min="0.1" max="100" step="0.1" value="1.0">
                <div class="value-display-container">
                    <span class="value-display" id="speedValue">1.0x</span>
                    <input type="number" id="speedInput" class="speed-input" min="0.000001" max="1000000" step="0.1" value="1.0">
                </div>
            </div>
            <button id="pauseButton">Pause</button>
            <button id="resetButton">Reset</button>
        </div>

        <div class="control-group">
            <div class="control-title">Appearance</div>
            <button id="togglePoints">Toggle Points</button>
            <button id="themeButton">Change Theme</button>
            <button id="resetThemeButton">Reset Theme</button>
            <div class="color-picker-container">
                <label for="whiteColorPicker">White Side:</label>
                <input type="color" id="whiteColorPicker" value="#FFFFFF">
            </div>
            <div class="color-picker-container">
                <label for="blackColorPicker">Black Side:</label>
                <input type="color" id="blackColorPicker" value="#000000">
            </div>
        </div>

        <div class="control-group">
            <div class="control-title">Ball Properties</div>
            <div class="slider-container">
                <label for="sizeSlider">Ball Size:</label>
                <input type="range" id="sizeSlider" min="15" max="35" step="1" value="25">
                <div class="value-display" id="sizeValue">25px</div>
            </div>
            <div class="slider-container">
                <label for="velocitySlider">Initial Velocity:</label>
                <input type="range" id="velocitySlider" min="1" max="8" step="0.5" value="4">
                <div class="value-display" id="velocityValue">4.0</div>
            </div>
        </div>
    </div>
</div>

<script>
    // Constants and configuration
    const CENTER = { x: 200, y: 200 };
    const MAIN_RADIUS = 180;
    const MED_RADIUS = 90;
    let SMALL_RADIUS = 25;
    let SHOW_POINTS = false;
    let PAUSED = true;
    let BACKGROUND_COLOR = "antiquewhite";
    let whiteSideColor = "#FFFFFF";
    let blackSideColor = "#000000";
    let SIMULATION_SPEED = 1.0;
    let INITIAL_VELOCITY = 4.0;

    // Canvas setup
    const canvas = document.getElementById('simulationCanvas');
    const ctx = canvas.getContext('2d');

    // Data structure for the simulation
    const data = {
        border: [],
        whiteOuter: [],
        whiteBall: { x: 0, y: 0, r: SMALL_RADIUS, v: { x: 0, y: 0 } },
        blackBall: { x: 0, y: 0, r: SMALL_RADIUS, v: { x: 0, y: 0 } }
    };

    // Utility functions
    function degreesToRadians(deg) {
        return deg * Math.PI / 180;
    }

    function normalize(p) {
        const len = Math.sqrt(p.x * p.x + p.y * p.y);
        if (len === 0) return { x: 0, y: 0 };
        return { x: p.x / len, y: p.y / len };
    }

    function dot(p1, p2) {
        return p1.x * p2.x + p1.y * p2.y;
    }

    function len(v) {
        return Math.sqrt(dot(v, v));
    }

    function sub(p1, p2) {
        return { x: p1.x - p2.x, y: p1.y - p2.y };
    }

    function mult(p, s) {
        return { x: p.x * s, y: p.y * s };
    }

    function dist(a, b) {
        return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
    }

    function distToLineSegment(item, p1, p2) {
        const l2 = dist(p1, p2) ** 2;
        if (l2 === 0) return dist(item, p1);

        let t = ((item.x - p1.x) * (p2.x - p1.x) + (item.y - p1.y) * (p2.y - p1.y)) / l2;
        t = Math.max(0, Math.min(1, t));

        return dist(item, {
            x: p1.x + t * (p2.x - p1.x),
            y: p1.y + t * (p2.y - p1.y)
        });
    }

    // Generate points along an arc
    function arcOfPoints(cx, cy, r, fromDeg, toDeg, nPoints) {
        const points = [];
        const fromRad = degreesToRadians(fromDeg);
        const toRad = degreesToRadians(toDeg);
        const angleRange = toRad - fromRad;

        for (let i = 0; i < nPoints; i++) {
            const angle = fromRad + (angleRange * i / nPoints);
            points.push({
                x: cx + Math.cos(angle) * r,
                y: cy + Math.sin(angle) * r
            });
        }
        return points;
    }

    // Physics calculations
    function bounceFromCircle(c, item, itemV) {
        const directionOfHitPoint = normalize(sub(item, c));
        const normal = directionOfHitPoint;
        const v = normalize(itemV);
        const projectedVelocity = dot(normal, v);
        const newDir = sub(v, mult(normal, 2 * projectedVelocity));
        return mult(newDir, len(itemV));
    }

    // Initialize simulation
    function initSimulation() {
        const blackBorder = arcOfPoints(CENTER.x, CENTER.y + MED_RADIUS, MED_RADIUS, 90, 270, 60);
        const whiteBorder = arcOfPoints(CENTER.x, CENTER.y - MED_RADIUS, MED_RADIUS, 90, -90, 60);

        data.border = [...blackBorder, ...whiteBorder];
        data.whiteOuter = arcOfPoints(CENTER.x, CENTER.y, MAIN_RADIUS, 270, 450, 60);

        // --- MODIFIED ---
        // Generate random starting angles for the balls
        const whiteAngle = Math.random() * Math.PI * 2;
        const blackAngle = Math.random() * Math.PI * 2;

        data.whiteBall = {
            x: CENTER.x,
            y: CENTER.y - MED_RADIUS,
            r: SMALL_RADIUS,
            v: {
                x: Math.cos(whiteAngle) * INITIAL_VELOCITY,
                y: Math.sin(whiteAngle) * INITIAL_VELOCITY
            }
        };

        data.blackBall = {
            x: CENTER.x,
            y: CENTER.y + MED_RADIUS,
            r: SMALL_RADIUS,
            v: {
                x: Math.cos(blackAngle) * INITIAL_VELOCITY,
                y: Math.sin(blackAngle) * INITIAL_VELOCITY
            }
        };
    }

    // Refill border points to prevent tunneling
    function refillBorder(points) {
        const MIN_DISTANCE = 8; // Minimum distance between points
        const MAX_DISTANCE = 15; // Maximum distance between points

        let newPoints = [points[0]];

        // First pass: add points where gaps are too large
        for (let i = 1; i < points.length; i++) {
            const p1 = points[i-1];
            const p2 = points[i];
            const distance = dist(p1, p2);

            if (distance > MAX_DISTANCE) {
                // Add intermediate points
                const segments = Math.ceil(distance / MAX_DISTANCE);
                for (let j = 1; j < segments; j++) {
                    const ratio = j / segments;
                    newPoints.push({
                        x: p1.x + (p2.x - p1.x) * ratio,
                        y: p1.y + (p2.y - p1.y) * ratio
                    });
                }
            }

            newPoints.push(p2);
        }

        // Second pass: remove points that are too close together
        const filteredPoints = [newPoints[0]];
        for (let i = 1; i < newPoints.length; i++) {
            const lastPoint = filteredPoints[filteredPoints.length - 1];
            const currentPoint = newPoints[i];

            if (dist(lastPoint, currentPoint) >= MIN_DISTANCE) {
                filteredPoints.push(currentPoint);
            }
        }

        return filteredPoints;
    }

    // --- MODIFIED FUNCTION ---
    // Move an object based on its velocity.
    // The SIMULATION_SPEED multiplier has been removed. Speed is now controlled by the update frequency in the animate() loop.
    function move(item) {
        return {
            ...item,
            x: item.x + item.v.x,
            y: item.y + item.v.y
        };
    }

    // Handle collisions
    function handleCollisions() {
        for (const ball of [data.whiteBall, data.blackBall]) {
            let movedBall = move(ball);
            let newV = { ...ball.v };
            let hit = false;
            const hitPoints = [];

            const newBorder = [];
            for (const p of data.border) {
                if (dist(p, movedBall) < ball.r - 4) {
                    const movedPoint = {
                        x: p.x + (newV.x * 1.5),
                        y: p.y + (newV.y * 1.5)
                    };

                    if (dist(movedPoint, CENTER) >= MAIN_RADIUS) {
                        newBorder.push(p);
                    } else {
                        newBorder.push(movedPoint);
                    }

                    hitPoints.push(p);
                    hit = true;
                } else {
                    newBorder.push(p);
                }
            }

            if (dist(movedBall, CENTER) >= MAIN_RADIUS - ball.r) {
                newV = bounceFromCircle(CENTER, movedBall, newV);
            } else if (hit) {
                newV = bounceFromCircle(hitPoints[0], movedBall, newV);
            }

            // Refill border to prevent tunneling
            data.border = refillBorder(newBorder);

            if (ball === data.whiteBall) {
                data.whiteBall = { ...ball, v: newV };
            } else {
                data.blackBall = { ...ball, v: newV };
            }
        }
    }

    // Render the simulation
    function render() {
        // Clear canvas
        ctx.fillStyle = BACKGROUND_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw main circle
        ctx.fillStyle = blackSideColor;
        ctx.beginPath();
        ctx.arc(CENTER.x, CENTER.y, MAIN_RADIUS, 0, Math.PI * 2);
        ctx.fill();

        // Draw white area
        ctx.fillStyle = whiteSideColor;
        ctx.beginPath();

        // Add white outer points
        if (data.whiteOuter.length > 0) {
            ctx.moveTo(data.whiteOuter[0].x, data.whiteOuter[0].y);
            for (let i = 1; i < data.whiteOuter.length; i++) {
                ctx.lineTo(data.whiteOuter[i].x, data.whiteOuter[i].y);
            }
        }

        // Add border points
        if (data.border.length > 0) {
            ctx.lineTo(data.border[0].x, data.border[0].y);
            for (let i = 1; i < data.border.length; i++) {
                ctx.lineTo(data.border[i].x, data.border[i].y);
            }
        }

        ctx.closePath();
        ctx.fill();

        // Draw points if enabled
        if (SHOW_POINTS) {
            ctx.fillStyle = "red";
            for (const point of data.border) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            for (const point of data.whiteOuter) {
                ctx.beginPath();
                ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Draw white ball
        ctx.fillStyle = whiteSideColor;
        ctx.beginPath();
        ctx.arc(data.whiteBall.x, data.whiteBall.y, data.whiteBall.r, 0, Math.PI * 2);
        ctx.fill();

        // Draw black ball
        ctx.fillStyle = blackSideColor;
        ctx.beginPath();
        ctx.arc(data.blackBall.x, data.blackBall.y, data.blackBall.r, 0, Math.PI * 2);
        ctx.fill();

        // Draw pause indicator if paused
        if (PAUSED) {
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = "white";
            ctx.font = "bold 36px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
        }
    }

    // --- Game Loop with Fixed Timestep ---
    let lastTime = 0;
    let accumulator = 0;
    const dt = 1000 / 60; // Fixed timestep for physics updates (60 updates per second).

    function animate(currentTime = 0) {
        if (!lastTime) {
            lastTime = currentTime;
        }
        const frameTime = currentTime - lastTime;
        lastTime = currentTime;

        // Add frame time to accumulator, scaled by the simulation speed.
        // This allows the simulation to run faster or slower than real-time.
        accumulator += frameTime * SIMULATION_SPEED;

        // Process physics updates in fixed steps (dt) until the accumulator is caught up.
        while (accumulator >= dt) {
            if (!PAUSED) {
                handleCollisions();
                data.whiteBall = move(data.whiteBall);
                data.blackBall = move(data.blackBall);

                // Keep balls within bounds after moving
                if (dist(data.whiteBall, CENTER) > MAIN_RADIUS - data.whiteBall.r) {
                    const angle = Math.atan2(data.whiteBall.y - CENTER.y, data.whiteBall.x - CENTER.x);
                    data.whiteBall.x = CENTER.x + Math.cos(angle) * (MAIN_RADIUS - data.whiteBall.r - 1);
                    data.whiteBall.y = CENTER.y + Math.sin(angle) * (MAIN_RADIUS - data.whiteBall.r - 1);
                }

                if (dist(data.blackBall, CENTER) > MAIN_RADIUS - data.blackBall.r) {
                    const angle = Math.atan2(data.blackBall.y - CENTER.y, data.blackBall.x - CENTER.x);
                    data.blackBall.x = CENTER.x + Math.cos(angle) * (MAIN_RADIUS - data.blackBall.r - 1);
                    data.blackBall.y = CENTER.y + Math.sin(angle) * (MAIN_RADIUS - data.blackBall.r - 1);
                }
            }
            accumulator -= dt;
        }

        // Render the current state. This is done once per frame, regardless of physics updates.
        render();
        requestAnimationFrame(animate);
    }

    // Set up event listeners
    function setupEventListeners() {
        // Mouse movement to start simulation
        canvas.addEventListener('mousemove', () => {
            if (PAUSED) {
                PAUSED = false;
                document.getElementById('pauseButton').textContent = 'Pause';
            }
        });

        // Pause button
        document.getElementById('pauseButton').addEventListener('click', () => {
            PAUSED = !PAUSED;
            document.getElementById('pauseButton').textContent = PAUSED ? 'Resume' : 'Pause';
        });

        // Reset button
        document.getElementById('resetButton').addEventListener('click', () => {
            initSimulation();
            PAUSED = false;
            document.getElementById('pauseButton').textContent = 'Pause';
        });

        // Toggle points button
        document.getElementById('togglePoints').addEventListener('click', () => {
            SHOW_POINTS = !SHOW_POINTS;
        });

        // Fullscreen button
        const fullscreenButton = document.getElementById('fullscreenButton');
        const canvasContainer = document.querySelector('.canvas-container');
        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                canvasContainer.requestFullscreen().catch((err) => {
                    console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                });
            } else {
                document.exitFullscreen();
            }
        });

        document.addEventListener('fullscreenchange', () => {
            if (document.fullscreenElement) {
                canvasContainer.classList.add('fullscreen-active');
                fullscreenButton.textContent = 'Exit Fullscreen';
            } else {
                canvasContainer.classList.remove('fullscreen-active');
                fullscreenButton.textContent = 'Fullscreen';
            }
        });

        // Theme button
        document.getElementById('themeButton').addEventListener('click', () => {
            const colors = [
                '#1c1c4f', '#4f1c1c', '#1c4f1c', '#4f4f1c', '#1c4f4f',
                '#4f1c4f', '#3c1c6f', '#6f3c1c', '#1c6f3c', '#6f6f1c',
                '#2a3b4c', '#5d4a4a', '#4a5d4a', '#5d5d4a', '#4a5d5d'
            ];

            // Generate random colors for elements
            const bgColor = colors[Math.floor(Math.random() * colors.length)];
            const uiColor = colors[Math.floor(Math.random() * colors.length)];
            const canvasBgColor = colors[Math.floor(Math.random() * colors.length)];

            BACKGROUND_COLOR = canvasBgColor;

            // Update background
            document.body.style.background = bgColor;
            document.querySelector('.container').style.background = `rgba(${parseInt(bgColor.slice(1, 3), 16)}, ${parseInt(bgColor.slice(3, 5), 16)}, ${parseInt(bgColor.slice(5, 7), 16)}, 0.8)`;

            // Update UI colors
            document.querySelectorAll('.control-group').forEach(el => {
                el.style.background = `rgba(${parseInt(uiColor.slice(1, 3), 16)}, ${parseInt(uiColor.slice(3, 5), 16)}, ${parseInt(uiColor.slice(5, 7), 16)}, 0.7)`;
            });

            document.querySelectorAll('button').forEach(btn => {
                btn.style.background = uiColor;
            });
        });

        // Reset Theme button
        document.getElementById('resetThemeButton').addEventListener('click', () => {
            // Reset background colors
            document.body.style.background = '#1c1c4f';
            document.querySelector('.container').style.background = 'rgba(28, 28, 79, 0.8)';

            BACKGROUND_COLOR = "antiquewhite";

            // Reset ball and side colors
            whiteSideColor = "#FFFFFF";
            blackSideColor = "#000000";
            document.getElementById('whiteColorPicker').value = "#FFFFFF";
            document.getElementById('blackColorPicker').value = "#000000";


            // Reset UI colors
            document.querySelectorAll('.control-group').forEach(el => {
                el.style.background = 'rgba(39, 39, 109, 0.7)';
            });

            document.querySelectorAll('button').forEach(btn => {
                btn.style.background = '#4c4c9f';
            });
        });

        // Color Pickers
        document.getElementById('whiteColorPicker').addEventListener('input', (e) => {
            whiteSideColor = e.target.value;
        });

        document.getElementById('blackColorPicker').addEventListener('input', (e) => {
            blackSideColor = e.target.value;
        });

        // Speed slider
        document.getElementById('speedSlider').addEventListener('input', (e) => {
            const newSpeed = parseFloat(e.target.value);
            SIMULATION_SPEED = newSpeed;
            document.getElementById('speedValue').textContent = `${newSpeed.toFixed(1)}x`;
            document.getElementById('speedInput').value = newSpeed.toFixed(1);
        });

        // Custom speed input
        document.getElementById('speedInput').addEventListener('change', (e) => {
            let newSpeed = parseFloat(e.target.value);
            const speedSlider = document.getElementById('speedSlider');

            // Validate and clamp the input
            if (isNaN(newSpeed)) {
                newSpeed = 1;
            }

            SIMULATION_SPEED = newSpeed;
            speedSlider.value = newSpeed;

            // Update the text displays
            document.getElementById('speedValue').textContent = `${newSpeed.toFixed(1)}x`;
            e.target.value = newSpeed.toFixed(1); // Format the input field's value
        });

        // Size slider
        document.getElementById('sizeSlider').addEventListener('input', (e) => {
            SMALL_RADIUS = parseInt(e.target.value);
            document.getElementById('sizeValue').textContent = `${SMALL_RADIUS}px`;

            data.whiteBall.r = SMALL_RADIUS;
            data.blackBall.r = SMALL_RADIUS;
        });

        // Velocity slider
        document.getElementById('velocitySlider').addEventListener('input', (e) => {
            INITIAL_VELOCITY = parseFloat(e.target.value);
            document.getElementById('velocityValue').textContent = INITIAL_VELOCITY.toFixed(1);

            // Reinitialize to apply new velocity
            initSimulation();
        });
    }

    // Initialize and start the simulation
    function init() {
        initSimulation();
        setupEventListeners();
        // Start the animation loop
        requestAnimationFrame(animate);
    }

    // Start everything when the page loads
    window.addEventListener('load', init);
</script>
</body>
</html>
